class WebSummit
types

values

instance variables

	private conferences : set of Conference := {};
	private exhibit : Exhibit := new Exhibit();
	private attendees : set of Attendee := {};-- nao sei se isto vai ser apagado
	
	-- default dates
	private initialDate : Utils`Date := mk_Utils`Date(2001,1,1);
	private finalDate : Utils`Date := mk_Utils`Date(2001,1,2);
	
	private static websummit: WebSummit := new WebSummit();
	
	inv not exists c1, c2 in set conferences & c1 <> c2 and c1.GetName() = c2.GetName();
	inv not exists a1, a2 in set attendees & a1 <> a2 and a1.GetID() = a2.GetID();
	
operations

	-- constructor of the websummit class 
		public WebSummit :  () ==> WebSummit
	  	WebSummit () == (
	  		return self
	  	);
	  	
	-- singleton - return the existent instance
		public pure static GetInstance: () ==> WebSummit 
			GetInstance() == return websummit;
	  	
	-- singleton - reset the instance
	public static ClearInstance: () ==> WebSummit
		ClearInstance() == (
			websummit := new WebSummit();
			return GetInstance();
		)
		post RESULT.conferences = {} and RESULT.exhibit.GetStartups() = {}
			 and RESULT.exhibit.GetInvestors() = {} and RESULT.attendees = {};
	  	
	 -- sets websummit dates
	 public SetDates : Utils`Date * Utils`Date ==> ()
	  	SetDates (d1, d2) == (
	  		initialDate := d1;
	  		finalDate := d2;
	  	)
	  	post initialDate = d1 and finalDate = d2;
	  	
	 --  returns websummit initial date
	 pure public GetInitialDate : () ==> Utils`Date
	  	GetInitialDate () == (
	  		return initialDate
	  	);
	  	
	 -- returns websummit final date
	 pure public GetFinalDate : () ==> Utils`Date
	  	GetFinalDate () == (
	  		return finalDate
	  	);	
			
	 -- creates a new conference
	 public AddConference : Conference ==> ()
	  	AddConference (conference) == (
	  		conferences := conferences union {conference};
	  	)
	  	pre conference not in set conferences and notAlreadyExistent(conference) = true
			post conferences = conferences~ union {conference};
	  			
	 -- removes a talk from an existing conference
	  public RemoveTalk : Conference * Talk ==> ()
	  	RemoveTalk (conference, talk) == (
	  		conference.RemoveTalk(talk);
	  	)
	  	pre conference in set conferences;
	  			
	 -- adds a new company to an existing conference
	  public AddCompany : Conference * Company ==> ()
	  	AddCompany (conference, company) == (
	  		conference.AddCompany(company);
	  	)
	  	pre conference in set conferences;
	  	
	  -- removes a company from an existing conference
	  public RemoveCompany : Conference * Company ==> ()
	  	RemoveCompany (conference, company) == (
	  		conference.RemoveCompany(company);
	  	)
	  	pre conference in set conferences;
	  	
	  	
	  -- adds a speaker no an existent talk
	  public AddSpeaker: Talk * Influential ==> ()
	  	AddSpeaker (talk, speaker) == (
	  		talk.AddSpeaker(speaker);
	  		if(speaker not in set attendees)
	  			then attendees := attendees union {speaker}
	  	)
	  	pre hd GetConference(talk.GetConference()) in set conferences	 --todas as talks de todas as conferences
	  	post speaker in set attendees; 	-- todos os influentials estao inscritos
  	
	  -- removes a speaker from an existent conference
	  public RemoveSpeaker: Talk * Influential ==> ()
	  	RemoveSpeaker (talk, speaker) == (
	  		talk.RemoveSpeaker(speaker);
	  	)
	  	pre hd GetConference(talk.GetConference()) in set conferences -- todas as talks de todas as conferences 
	  	post speaker in set attendees;
	  	
	 -- returns all confereces
	 pure public GetConferences : () ==> set of Conference
	  	GetConferences () == (
	  		return conferences
	  	);
	  	
	 -- returns a specific conferece by it's name
	 public pure GetConference : Utils`String ==> seq of Conference
	  	GetConference (conferenceName) == (
	  		dcl result: seq of Conference := [];
	  		
	  		for all conference in set conferences do (
	  			if conference.GetName() = conferenceName
	  			then result := result ^ [conference];
	  		);
	  		
	  		return result
	  	)
		pre len conferenceName > 0
		post RESULT = [] or len RESULT = 1;
		
		
		-- returns the full schedule of a conference
	 public GetSchedule : Conference ==> map Utils`Date to seq of Talk
	  	GetSchedule (c) == (
	  		return c.GetSchedule();
	  	)
	  	pre c in set conferences;
	  	
	 -- returns the full event schedule
	 public GetSchedule : () ==> map Utils`Date to seq of Talk
	  	GetSchedule () == (
	  		dcl temp: map Utils`Date to seq of Talk := {|->};
	  		dcl currentDate : Utils`Date := initialDate;
	  		
	  		-- joins all the events
	  		for all conference in set conferences do (
	  			if(temp = {|->})
	  				then temp := conference.GetSchedule()
	  				else 
	  				(
	  					while (currentDate <> Utils`nextDay(finalDate))
						    do (
						    	  temp(currentDate) := temp(currentDate) ^ conference.GetSchedule(currentDate);
						    		currentDate := Utils`nextDay(currentDate);
						    		);
	  				);
	  		);
	  		
	  		currentDate := WebSummit`GetInstance().GetInitialDate();
	  		
	  		-- orders them by time
	  		
	  		while (currentDate <> Utils`nextDay(finalDate))
			  do (
			 
						temp(currentDate) := Utils`mergeSortTalks(temp(currentDate));
						currentDate := Utils`nextDay(currentDate);
				);
						    
	  		return temp;
	  	);	  
	  	
	 -- returns the event schedule by date/time
	 public GetSchedule : Utils`Date * Utils`Time ==> seq of Talk
	  	GetSchedule (date, time) == (
	  		dcl temp: seq of Talk := [];
	  		
	  		-- joins all the events from that day
	  		for all conference in set conferences do (
	  			for all talk in set elems conference.GetSchedule()(date) do
	  			(
	  				if(talk.GetTime().hour = time.hour)
	  				then temp := temp ^ [talk]
	  				else
	  					if(talk.GetTime().hour + 1 = time.hour)
	  					then if(talk.GetTime().minute + talk.GetDuration() >= 60)
	  						then if(talk.GetTime().minute + talk.GetDuration() - 60 < 60)
	  							then temp := temp ^ [talk]
	  			);
	  			
	  		);
	  		
	  		-- orders them by time
				temp := Utils`mergeSortTalks(temp);
						    
	  		return temp;
	  	);	  
	  	
	  -- adds a new attendee to an existing talk
	 public AddAttendee : Talk * Attendee ==> ()
	  	AddAttendee (talk, attendee) == (
	  		talk.AddAttendee(attendee);
	  		if(attendee not in set attendees)
	  			then attendees := attendees union {attendee}
	  	)
	  	pre hd GetConference(talk.GetConference()) in set conferences
	  	post attendee in set attendees;	
		
		-- checks if a conference with the same name doesn't exist already: for precondition of AddConference
	   pure private notAlreadyExistent : Conference ==> bool
	  	notAlreadyExistent (newConference) == (
	  	dcl doesntExist : bool := true;
	  	for all conference in set conferences do (
	  		if(conference.GetName() = newConference.GetName())
			  then(
			  			doesntExist := false;
			  			return doesntExist
			  		)
	  		);
	  		
	  		return doesntExist;
	  	)
	  	pre newConference not in set conferences;
	  	
	 -- NOTA: tem de ter metodo para ir buscar attendee por id para poder removï¿½-los e outro para listar os attendees e speakers
	
	-- returns all websummit attendees
	 public GetAttendees : () ==> set of Attendee
	  	GetAttendees () == (
	  		return attendees;
	  	);  	

functions

traces

end WebSummit