class Conference
types
	
values

instance variables

	private name : Utils`String := [];
	private description : Utils`String := [];
	private talks : set of Talk := {};
	private companies : set of Company := {};
	
operations
		
	  -- constructor of the conference class 
		public Conference : Utils`String * Utils`String ==> Conference
	  	Conference (conferenceName, conferenceDescription) == (
	  		name := conferenceName;
	  		description := conferenceDescription;
	  		return self
	  	)
	  	pre len conferenceName > 0;
	  	
	 -- returns the conference name
	 pure public GetName : () ==> Utils`String
	  	GetName () == (
	  		return name;
	  	);
	  	
	-- set the conference name
	 public SetName : Utils`String ==> ()
	  	SetName (n) == (
	  		name := n;
	  	);
	  	
	 -- returns the conference description
	 pure public GetDescription : () ==> Utils`String
	  	GetDescription () == (
	  		return description;
	  	);
	  	
	 -- set the conference description
	 public SetDescription : Utils`String ==> ()
	  	SetDescription (d) == (
	  		description := d;
	  	);
	  	
	 -- returns the conference talks
	 pure public GetTalks : () ==> set of Talk
	  	GetTalks () == (
	  		return talks;
	  	);
	  	
	  -- returns a conference talk by it's name
	 public GetTalk : Utils`String ==> seq of Talk
	  	GetTalk (talkName) == (
	  		dcl result: seq of Talk := [];
	  		
	  		for all talk in set talks do (
	  			if (talk.GetName() = talkName)
	  			then result := result ^ [talk];
	  		);
	  		
	  		return result
	  	)
	  	pre len talkName > 0
			post RESULT = [] or len RESULT = 1;
			
	-- returns a conference talk by it's time: required for GetSchedule operation
	pure public GetTalk : Utils`Date * Utils`Time ==> seq of Talk
	  	GetTalk (talkDate, talkTime) == (
	  		dcl result: seq of Talk := [];
	  		
	  		for all talk in set talks do (
	  		  if talk.GetDate() = talkDate
	  		  then
	  			if talk.GetTime() = talkTime
	  			then result := result ^ [talk];
	  		);
	  		
	  		return result
	  	)
	  	pre talkTime.hour >= 0 and talkTime.hour < 24 and talkTime.minute >= 0 and talkTime.minute < 60
			post RESULT = [] or len RESULT = 1;
	  	
	 
	  -- returns the conference attending companies
	 pure public GetCompanies : () ==> set of Company
	  	GetCompanies () == (
	  		return companies;
	  	);
	  	
	 -- adds a new talk to the conference
	 public AddTalk : Talk ==> ()
	  	AddTalk (talk) == (
	  	  talk.SetConference(name);
	  		talks := talks union {talk};
	  	)
	  	pre talk not in set talks and notAlreadyExistent(talk) = true and (DoesntOverlap(talk)) = true
			post talks = talks~ union {talk};
			
	 -- remove Talk
	 public RemoveTalk : Talk ==> ()
	  	RemoveTalk (talk) == (
	  		talks := talks \ {talk};
	  	)
	  	pre talk in set talks and card talks >= 1
			post talks = talks~ \ {talk};
	  	
	-- adds a new company attending the conference
  public AddCompany : Company ==> ()
	  	AddCompany (company) == (
	  		companies := companies union {company};
	  	)
	  	pre company not in set companies and notAlreadyExistent(company) = true
			post companies = companies~ union {company};
			
	-- remove company attending
	public RemoveCompany : Company ==> ()
	  	RemoveCompany (company) == (
	  		companies := companies \ {company};
	  	)
	  	pre company in set companies and card companies >= 1
			post companies = companies~ \ {company};
			
	 -- returns schedule of the day, sorted by time
	 -- NOTE: n�o sei que p�s condi��es p�r aqui
	pure public GetSchedule : Utils`Date ==> seq of Talk
	  	GetSchedule (date) == (
	    	dcl talkSet: seq of Talk := [];
	    	
	  		for all talk in set talks do (
	  		if(talk.GetDate() = date)
	  			then talkSet := talkSet ^ [talk];
	  		);
	
	  		return Utils`mergeSortTalks(talkSet);
	  	)
	  	pre date.month >= 1 and date.month <= 12 and date.day >= 1 and date.day <= Utils`DaysOfMonth(date.year,date.month);
	  	
	 -- returns schedule of the conference, sorted
   pure public GetSchedule : () ==> map Utils`Date to seq of Talk
	  	GetSchedule () == (
	  		dcl result: map Utils`Date to seq of Talk := {|->};
	    	dcl currentDate : Utils`Date := WebSummit`GetInstance().GetInitialDate();
	    	dcl finalDate : Utils`Date := WebSummit`GetInstance().GetFinalDate();

	    	while (currentDate <> Utils`nextDay(finalDate))
	    	do (
	    		 result := result munion {currentDate |-> GetSchedule(currentDate)};
	    		 currentDate := Utils`nextDay(currentDate);
	    		 );
	  		
	  		return result
	  	);
	  	
	  	
	 -- checks if talk doesnt overlap existing one: for precondition of AddTalk
	 pure private DoesntOverlap : Talk ==> bool
	  	DoesntOverlap (newTalk) == (
	  	dcl doesntOverlap : bool := true;
	  	
	  	for all talk in set talks do (
	  		if(talk.GetDate() = newTalk.GetDate())
	  			then if(Utils`DoesntOverlap(newTalk.GetTime(), newTalk.GetDuration(), talk.GetTime(), talk.GetDuration()) = false)
			  					 then 
			  					 (
			  					 			doesntOverlap := false;
			  					 			return doesntOverlap
			  					 )
	  		);
	  		
	  		return doesntOverlap;
	  	)
	  	pre newTalk not in set talks;
	  	
	 -- checks if a talk with the same name doesn't exist already: for precondition of AddTask
	   pure private notAlreadyExistent : Talk ==> bool
	  	notAlreadyExistent (newTalk) == (
	  	dcl doesntExist : bool := true;
	  	for all talk in set talks do (
	  		if(talk.GetName() = newTalk.GetName())
			  then(
			  			doesntExist := false;
			  			return doesntExist
			  		)
	  		);
	  		
	  		return doesntExist;
	  	)
	  	pre newTalk not in set talks;
	  	
	  -- checks if a company with the same name doesn't exist already: for precondition of AddCompany
	   pure private notAlreadyExistent : Company ==> bool
	  	notAlreadyExistent (newCompany) == (
	  	dcl doesntExist : bool := true;
	  	for all company in set companies do (
	  		if(company.GetName() = newCompany.GetName())
			  then(
			  			doesntExist := false;
			  			return doesntExist
			  		)
	  		);
	  		
	  		return doesntExist;
	  	)
	  	pre newCompany not in set companies;
			
	 
functions

traces

end Conference