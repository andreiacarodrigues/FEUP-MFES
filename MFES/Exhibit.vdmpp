class Exhibit
types

values

instance variables

	private startups : set of Startup := {};
	private investors : set of Influential := {};
	
	inv not exists s1, s2 in set startups & s1 <> s2 and s1.GetName() = s2.GetName();
	inv not exists i1, i2 in set investors & i1 <> i2 and i1.GetID() = i2.GetID();
	
operations

 	-- default constructor of the exibit class 
	public Exhibit : () ==> Exhibit
		Exhibit () == (
	 		return self
	  );
	  	
	-- returns the exibit startups
	pure public GetStartups : () ==> set of Startup
	 	GetStartups () == (
  		return startups;
  	);
  	
  pure public GetStartup : Utils`String ==> seq of Startup
	  GetStartup (name) == (
	  	dcl result: seq of Startup := [];
	  		
	  	for all startup in set startups do (
	  		if (startup.GetName() = name)
	  			then result := result ^ [startup];
	  		);
	  		
	  		return result
	  	)
	  	pre len name > 0
			post RESULT = [] or len RESULT = 1;	
	  
	-- add startup
	public AddStartup: Startup ==> ()
		AddStartup (startup) == (
	  	startups := startups union {startup}
	  )
	  pre startup not in set startups	and len GetStartup(startup.GetName()) = 0
	  post startups = startups~ union {startup};  
	
	-- remove startup
	public RemoveStartup: Startup ==> ()
  	RemoveStartup (startup) == (
  		startups := startups \ {startup};
	  )
	  pre startup in set startups and card startups >= 1
		post startups = startups~ \ {startup};
	
	-- returns the exibit investors
	pure public GetInvestors : () ==> set of Influential
		GetInvestors () == (
	  	return investors;
	  );
	
	pure public GetInvestor : Utils`String ==> seq of Influential
	  GetInvestor (name) == (
	  	dcl result: seq of Influential := [];
	  		
	  	for all investor in set investors do (
	  		if (investor.GetName() = name)
	  			then result := result ^ [investor];
	  		);
	  		
	  		return result
	  	)
	  	pre len name > 0
			post RESULT = [] or len RESULT = 1;	
	
	-- add investor
	public AddInvestor: Influential ==> ()
		AddInvestor (investor) == (
	  	investors := investors union {investor}
	  )
	  pre investor not in set investors	and len GetInvestor(investor.GetName()) = 0
	  post investors = investors~ union {investor};  
	  	
	-- remove investor
	public RemoveInvestor: Influential ==> ()
  	RemoveInvestor (investor) == (
  		investors := investors \ {investor};
	  )
	  pre investor in set investors and card investors >= 1
		post investors = investors~ \ {investor};	  	
	  	
functions

traces

end Exhibit